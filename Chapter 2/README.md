# 第二章 信息的表示和处理
## 2.1 
### A
0x39A7F8 的二进制表示：0011 1001 1010 0111 1111 1000

### B
1100100101111011 的十六进制表示：0xA97C

### C
0xD5E4C 的二进制表示：1101 0101 1110 0100 1100

### D
1001101110011110110101 的十六进制表示：0x26E7B5

## 2.2 

n|2^n (十进制)|2^n (十六进制)
---|-------|------
9|512|0x200
19|524288|0x80000
14|16384|0x4000
16|65536|0x10000
17|131072|0x20000
5|32|0x20
7|128|0x80

## 2.3
十进制|二进制|十六进制
---|-------|------
0 | 0000 0000 | 0x00
167 |1010 0111 | 0xA7
62 | 0011 1101 | 0x3D
188 | 1011 1100 | 0xBC
55 | 0011 0111 | 0x37
136 | 1000 1000 | 0x88
244 | 1111 0011 | 0xF3
82 | 0101 0010 | 0x52
172 | 1010 1100 | 0xAC
232 | 1110 0111 | 0xE7

## 2.4

### A
0x503c + 0x8 = 0x5044

### B
ox503c + 0x40 = 0x507c

### C
0x503c + 64 = 0x503c + 0x40 = 0x507c

### D
0x50ea - 0x503c = 0xae

## 2.5 
思考下面对 show_bytes 的三次调用：

```
int val = 0x87654321;
byte_pointer valp = (byte_pointer) &val;
show_bytes(valp, 1); /* A. */
show_bytes(valp, 2); /* B. */
show_bytes(valp, 3); /* C. */
```
指出再小端法机器和大端法机器上，每次调用的输出值。

A. 小端法：21 大端法： 87
B. 小端法：2143 大端法：8765
C. 小端法：214365 大端法：876543

## 2.6
使用 show_int 和 show_float，我们确定整数 3510593 的十六进制表示为 0x00359141，而浮点数 3510593.0 的十六进制表示为 0x4A564504。
A. 写出这两个十六进制值的二进制表示
B. 移动这两个二进制串的相对位置，使得它们相匹配的位数最多。有多少位相匹配呢？
C. 串中的什么部分不匹配？

A. 0x00359141 的二进制表示：00000000001101011001000101000001
	0x4A564504 的二进制表示：01001010010101100100010100000100
	
B. 
00000000001101011001000101000001
  01001010010101100100010100000100
  
  有 21 位相同，移动两位即可匹配
  
C. 前面 9 位 和最后两位不匹配

## 2.7
下面对 show_bytes 的调用将输出什么结果？

```
const char *s = "abcdef";
show_bytes((byte_pointer) s, strlen(s));
```
注意字母 ‘a’ ~ ‘z’ 的 ASCII 码为 0x61 ~ 0x7A。

0x616263646566

## 2.8
运算 | 结果
---- | ----
a | [01001001]
b | [01010101]
~a | [10010110]
~b | [10101010]
a & b | [01000001]
a \| b | [01111101]
a ^ b | [00111100]

## 2.9
通过混合三中不同颜色的光（红色、绿色和蓝色），计算机可以再视频屏幕或者液晶显示器上产生彩色的画面。设想一种简单的方法，使用三中不同颜色的光，每种光都能打开或者关闭，投射到玻璃屏幕上。
那么基于光源R（红）、G（绿）、B（蓝）的关闭（0）或打开（1），我们就能够创建 9 种不同的颜色：

R | G | B | 颜色 | R | G | B | 颜色
--- | --- | --- | --- | --- | --- | --- | ---
0 | 0 | 0 | 黑色 | 1 | 0 | 0 | 红色
0 | 0 | 1 | 蓝色 | 1 | 0 | 1 | 红紫色
0 | 1 | 0 | 绿色 | 1 | 1 | 0 | 黄色
0 | 1 | 1 | 蓝绿色 | 1 | 1 | 1 | 白色

这些颜色中的每一种都能用一个长度为 3 的位向量来表示，我们可以对他们进行布尔运算。
A. 一种颜色补是通过关掉打开的官员，且打开关闭的光源而形成的。那么上面列出的 8 种 颜色每一种的补是什么？

R | G | B | 颜色 | 补色 | R | G | B | 颜色 | 补色 
--- | --- | --- | --- | --- | --- | --- | --- | --- | ---
0 | 0 | 0 | 黑色 | 白色 | 1 | 0 | 0 | 红色 | 蓝绿色
0 | 0 | 1 | 蓝色 | 黄色 | 1 | 0 | 1 | 红紫色 | 绿色
0 | 1 | 0 | 绿色 | 红紫色 | 1 | 1 | 0 | 黄色 | 蓝色
0 | 1 | 1 | 蓝绿色 | 红色 | 1 | 1 | 1 | 白色 | 褐色

B. 描述下列颜色应用布尔运算的结果：
蓝色 | 绿色 == 蓝绿色
黄色 & 蓝绿色 ==  绿色
红色 ^ 红紫色 == 蓝色

## 2.10
对于任意一位向量 a， 有 a ^ a = 0。应用这一属性，考虑下面的程序：

```
void inplace_swap(int *x, int *y) {
	*y = *x ^ *y; /* Step 1 */
	*x = *x ^ *y; /* Step 2 */
	*y = *x ^ *y; /* Step 3 */
}
```
正如程序名所暗示的那样，我们认为这个过程的效果是交换指针变量 x 和 y 所指向的存储位置处存放的值。注意，与通常的交换两个数值的技术不一样，当移动一个值时，我们不需要第三个位置来临时存储另一个值。这种交换方式并没有性能上的优势，它仅仅是一个智力游戏。
以指针 x 和 y 指向的位置存储的值分别是 a 和 b 作为开始，填写下表，给出在程序的每一步之后，存储在这两个位置中的值。利用 ^ 的属性证明达到了所希望的结果。回想一下，每个元素就是它自身的加法逆元 (a ^ a = 0)。

步骤 | *x | *y 
--- | --- | ---
初始 | a  | b
第 1 步 | a | a ^ b
第 2 步 | b | a ^ b
第 3 步 | b | a

## 2.11
在练习题 2.10 中的 `inplace_swap` 函数的基础上，你决定写一段代码，实现将一个数组中的元素头尾两端依次对调。你写出下面这个函数：

```
void reverse_array(int a[], int cnt) {
	int first, last;
	for (first = 0, last = cnt - 1; first <= last); first++, last--) 
		inplace_swap(&a[first], &a[last]) 
}
```
当你对一个包含元素1、2、3 和 4 的数组使用这个函数时，正如预期的那样，现在数组的元素变成了 4、3、2 和 1.不过，当你对一个包含元素1、2、3、4 和 5 的数组使用这个函数时，你会很惊奇地看到得到的数字的元素为5、4、0、2 和 1.实际上，你会发现这段代码对所有偶数长度的数组都能正确地工作，但是当数组的长度为奇数时，它就会把中间的元素设置成 0。
A. 对于一个长度为奇数的数组，长度 `cnt = 2k + 1`，函数 `reverse_array` 最后一次循环中，变量 `first` 和 `last` 的值分别是什么？ `first = last = k`

B. 为什么这时调用函数 `inplace_swap` 会将数组元素设置为 0？因为这时候 `first` 和 `last` 相等，而根据 `a ^ a = 0` ，所以 `first` 和 `last` 就变成 `0` 了。

C. 对 `reverse_array` 的代码做哪些简单改动就能消除这个问题？ 把条件 `first <= last` 改成 `first < last` 即可。

## 2.12 
对于下面的值，写出变量 x 的 C 语言表达式。你的代码应该对任何字长 w >= 8 都能工作。我们给出了当 x=0x87654321 以及 w = 32 时表达式求值的结果，仅供参考。
A. x 的最低有效字节，其他位均置为 0。[0x00000021]。 x & 0x000000FF
B. 除了 x 的最低有效字节外，其他的位都取补，最低有效字节保持不变。[0x789ABC21]。 
x ^ 0xFFFFFF00
C. x 的最低有效字节设置成全 1，其他字节都保持不变。[0x876543FF]。x | 0x000000FF

## 2.13 
从 20 世纪 70 年代末到 80 年代末，Digital Equipment 的 VAX 计算机是一种非常刘姓的机型。它没有布尔运算 AND 和 OR 指令，只有 bis（位设置）和 bic（位清除）这两种指令。两种指令的输入都是一个数据字 x 和一个掩码字 m。它们生成一个结果 z，z 是由根据掩码 m 的位来修改 x 的位得到的。使用 bis 指令，这种修改就是在 m 为 1 的每个位置，将 z 对应的位设置为 0.

为了看清楚这些运算与 C 语言位级运算的关系，假设我们有两个函数 bis 和 bic 来实现位设置和位清除操作。只想用这两个函数，而不实用任何其他 C 语言运算，来实现按位 | 和 ^ 运算。填写下列代码中缺失的代码。提示：写出 bis 和 bic 的 C 语言表达式。

```
/ * Declarations of functions implementing operations bis and bic */
int bis(int x, int m);
int bic(int x, int m);

/ * Compute x|y using only calls to functions bis and bic */
int bool_or(int x, int y) {
	int result = bis(x, y);
	return result;
}

/ * Compute x^y using only calls to functions bis and bic */
int bool_xor(int x, int y) {
	int result = bis(bic(x, y), bic(y, x));
	return result;
}
```








